# -*- coding: utf-8 -*-
"""Retine_vessels_Seg.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PUSw7yt5sFOfcAEW0E80F9P3ONnfYFZ1
"""

from google.colab import files
files.upload()

import os
import numpy as np
import json
import scipy.io
import pandas as pd
import cv2
from tqdm import tqdm
from tensorflow.keras.preprocessing.image import load_img, img_to_array
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras import layers, Model

os.makedirs("/root/.kaggle", exist_ok=True)
!mv kaggle.json /root/.kaggle/
!chmod 600 /root/.kaggle/kaggle.json

!kaggle datasets download -d abdallahwagih/retina-blood-vessel

!unzip retina-blood-vessel.zip

!ls

os.listdir("/content/Data/train")

#img_size = (256, 256)
#base_path = "/content/Data/"
#train_img_dir = os.path.join(base_path, "train/image")
#train_mask_dir = os.path.join(base_path, "train/mask")
#test_img_dir = os.path.join(base_path, "test/image")
#test_mask_dir = os.path.join(base_path, "test/mask")

#sample_image_path = os.path.join(train_img_dir, os.listdir(train_img_dir)[0])

#img = load_img(sample_image_path)
#img_array = img_to_array(img)

#print("Image shape:", img_array.shape)

image_dir = "/content/Data/train/image"
mask_dir = "/content/Data/train/mask"
img_size = (512,512)

images = []
masks = []

for filename in os.listdir(image_dir):
    img_path = os.path.join(image_dir, filename)
    mask_path = os.path.join(mask_dir, filename)

    if os.path.exists(mask_path):
        img = load_img(img_path, target_size=img_size, color_mode="grayscale")
        img = img_to_array(img) / 255.0

        mask = load_img(mask_path, target_size=img_size, color_mode="grayscale")
        mask = img_to_array(mask) / 255.0

        images.append(img)
        masks.append(mask)

X = np.array(images)
Y = np.array(masks)


#X = np.expand_dims(X, axis=-1)
#Y = np.expand_dims(Y, axis=-1)

X_train, X_val, Y_train, Y_val = train_test_split(X, Y, test_size=0.2, random_state=42)

inputs = layers.Input(shape=(512, 512, 1))


c1 = layers.Conv2D(16, (3, 3), activation='relu', padding='same')(inputs)
c1 = layers.Conv2D(16, (3, 3), activation='relu', padding='same')(c1)
p1 = layers.MaxPooling2D((2, 2))(c1)

c2 = layers.Conv2D(32, (3, 3), activation='relu', padding='same')(p1)
c2 = layers.Conv2D(32, (3, 3), activation='relu', padding='same')(c2)
p2 = layers.MaxPooling2D((2, 2))(c2)


c3 = layers.Conv2D(64, (3, 3), activation='relu', padding='same')(p2)
c3 = layers.Conv2D(64, (3, 3), activation='relu', padding='same')(c3)


u1 = layers.UpSampling2D((2, 2))(c3)
u1 = layers.Concatenate()([u1, c2])
c4 = layers.Conv2D(32, (3, 3), activation='relu', padding='same')(u1)
c4 = layers.Conv2D(32, (3, 3), activation='relu', padding='same')(c4)

u2 = layers.UpSampling2D((2, 2))(c4)
u2 = layers.Concatenate()([u2, c1])
c5 = layers.Conv2D(16, (3, 3), activation='relu', padding='same')(u2)
c5 = layers.Conv2D(16, (3, 3), activation='relu', padding='same')(c5)

outputs = layers.Conv2D(1, (1, 1), activation='sigmoid')(c5)

model = Model(inputs=[inputs], outputs=[outputs])



#def dice_loss(y_true, y_pred, smooth=1e-6):
    #y_true_f = tf.keras.backend.flatten(y_true)
    #y_pred_f = tf.keras.backend.flatten(y_pred)
    #intersection = tf.keras.backend.sum(y_true_f * y_pred_f)
   # return 1 - (2. * intersection + smooth) / (tf.keras.backend.sum(y_true_f) + tf.keras.backend.sum(y_pred_f) + smooth)

#def bce_dice_loss(y_true, y_pred):
    #return tf.keras.losses.binary_crossentropy(y_true, y_pred) + dice_loss(y_true, y_pred)

def dice_loss(y_true, y_pred):
    smooth = 1e-6
    y_true_f = tf.keras.backend.flatten(y_true)
    y_pred_f = tf.keras.backend.flatten(y_pred)
    intersection = tf.keras.backend.sum(y_true_f * y_pred_f)
    return 1 - (2. * intersection + smooth) / (tf.keras.backend.sum(y_true_f) + tf.keras.backend.sum(y_pred_f) + smooth)

def combo_loss(y_true, y_pred):
    bce = tf.keras.losses.binary_crossentropy(y_true, y_pred)
    d_loss = dice_loss(y_true, y_pred)
    return bce + d_loss

model.compile(optimizer='adam', loss=combo_loss, metrics=['accuracy'])
model.summary()

model.fit(X_train, Y_train, validation_data=(X_val, Y_val), epochs=100, batch_size=8)

test_image_dir = "/content/Data/test/image"
test_mask_dir = "/content/Data/test/mask"

test_images = []
test_masks = []

for filename in os.listdir(test_image_dir):
    img_path = os.path.join(test_image_dir, filename)
    mask_path = os.path.join(test_mask_dir, filename)

    if os.path.exists(mask_path):
        img = load_img(img_path, target_size=img_size, color_mode="grayscale")
        img = img_to_array(img) / 255.0

        mask = load_img(mask_path, target_size=img_size, color_mode="grayscale")
        mask = img_to_array(mask) / 255.0

        test_images.append(img)
        test_masks.append(mask)

X_test = np.array(test_images)
Y_test = np.array(test_masks)

preds = model.predict(X_test)
preds = (preds > 0.5).astype(np.uint8)

n = 5

for i in range(n):
    plt.figure(figsize=(12, 4))


    plt.subplot(1, 3, 1)
    plt.imshow(X_test[i].squeeze(), cmap='gray')
    plt.title('Test Image')
    plt.axis('off')


    plt.subplot(1, 3, 2)
    plt.imshow(Y_test[i].squeeze(), cmap='gray')
    plt.title('True Mask')
    plt.axis('off')


    plt.subplot(1, 3, 3)
    plt.imshow(preds[i].squeeze(), cmap='gray')
    plt.title('Predicted Mask')
    plt.axis('off')

    plt.tight_layout()
    plt.show()

